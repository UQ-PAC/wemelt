package wemelt;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "Parser.grammar".
 */
public class Parser extends beaver.Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short PLUS = 1;
		static public final short MINUS = 2;
		static public final short ID = 3;
		static public final short NUM = 4;
		static public final short LPAREN = 5;
		static public final short BANG = 6;
		static public final short TILDE = 7;
		static public final short TRUE = 8;
		static public final short FALSE = 9;
		static public final short MEM = 10;
		static public final short STAR = 11;
		static public final short DIV = 12;
		static public final short MOD = 13;
		static public final short IF = 14;
		static public final short BV32 = 15;
		static public final short BV64 = 16;
		static public final short BV1 = 17;
		static public final short SHL = 18;
		static public final short SHR = 19;
		static public final short ASHR = 20;
		static public final short LOW = 21;
		static public final short HIGH = 22;
		static public final short SIGNED = 23;
		static public final short UNSIGNED = 24;
		static public final short GOT = 25;
		static public final short PREFIX = 26;
		static public final short POSTFIX = 27;
		static public final short LT = 28;
		static public final short LE = 29;
		static public final short GE = 30;
		static public final short GT = 31;
		static public final short EQ = 32;
		static public final short NEQ = 33;
		static public final short AMP = 34;
		static public final short CARET = 35;
		static public final short PIPE = 36;
		static public final short COLON = 37;
		static public final short AND = 38;
		static public final short PRIMEID = 39;
		static public final short OR = 40;
		static public final short COMMA = 41;
		static public final short WHILE = 42;
		static public final short DO = 43;
		static public final short SPECIAL = 44;
		static public final short LBRACE = 45;
		static public final short SEMICOLON = 46;
		static public final short RBRACK = 47;
		static public final short RPAREN = 48;
		static public final short LBRACK = 49;
		static public final short MEMSIZE = 50;
		static public final short ASG = 51;
		static public final short G_VAR = 52;
		static public final short P_INV = 53;
		static public final short RBRACE = 54;
		static public final short U32 = 55;
		static public final short U64 = 56;
		static public final short S32 = 57;
		static public final short S64 = 58;
		static public final short GLOBAL = 59;
		static public final short SIZE = 60;
		static public final short R_VAR = 61;
		static public final short GAMMA_0 = 62;
		static public final short INVARIANT = 63;
		static public final short GAMMA = 64;
		static public final short LOCAL = 65;
		static public final short MAPSTO = 66;
		static public final short ELSE = 67;
		static public final short LPREDGUAR = 68;
		static public final short EL = 69;
		static public final short BE = 70;
		static public final short P_0 = 71;
		static public final short WITH = 72;
		static public final short LARROW = 73;
		static public final short FENCE = 74;
		static public final short ISH = 75;
		static public final short RET = 76;
		static public final short THEN = 77;
		static public final short LPRED = 78;
		static public final short LPREDRELY = 79;

		static public final String[] NAMES = {
			"EOF",
			"PLUS",
			"MINUS",
			"ID",
			"NUM",
			"LPAREN",
			"BANG",
			"TILDE",
			"TRUE",
			"FALSE",
			"MEM",
			"STAR",
			"DIV",
			"MOD",
			"IF",
			"BV32",
			"BV64",
			"BV1",
			"SHL",
			"SHR",
			"ASHR",
			"LOW",
			"HIGH",
			"SIGNED",
			"UNSIGNED",
			"GOT",
			"PREFIX",
			"POSTFIX",
			"LT",
			"LE",
			"GE",
			"GT",
			"EQ",
			"NEQ",
			"AMP",
			"CARET",
			"PIPE",
			"COLON",
			"AND",
			"PRIMEID",
			"OR",
			"COMMA",
			"WHILE",
			"DO",
			"SPECIAL",
			"LBRACE",
			"SEMICOLON",
			"RBRACK",
			"RPAREN",
			"LBRACK",
			"MEMSIZE",
			"ASG",
			"G_VAR",
			"P_INV",
			"RBRACE",
			"U32",
			"U64",
			"S32",
			"S64",
			"GLOBAL",
			"SIZE",
			"R_VAR",
			"GAMMA_0",
			"INVARIANT",
			"GAMMA",
			"LOCAL",
			"MAPSTO",
			"ELSE",
			"LPREDGUAR",
			"EL",
			"BE",
			"P_0",
			"WITH",
			"LARROW",
			"FENCE",
			"ISH",
			"RET",
			"THEN",
			"LPRED",
			"LPREDRELY"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjN0UO54KQVRNT6sTtHOAIH40MMCbX0SavYC2IWqGLKD0pd3c0cD1J47DMZ0W6Z8SvWG4" +
		"3c04LSy24W9Y5kjVTrJtLFJCxnTxUfwVRyxr#bTwhlwewrBY3GC4768Dnw8lHc8m9c8XfE0" +
		"W3K2Y4oC8fw8NUw8DSn927Wt4OZiHnw8SUw9bU9GhAfQfUBbLDSnNoWt7LGXtiPQYwgLogM" +
		"mBLtRW7zncglYYNwlT0DHAZO1ced7PseBeAsRZMGFMLiF1veFgMkTzCLEudKBcVj2fXYTou" +
		"YhazJLJO98QAuO6ggsWZ3AuDqHCvegMcQY#bWQeRM$RGL7r5AmFLGBOSeAds5xqDnhMx$1f" +
		"x1dDO4xLHrq1L3$NHC50rGcCqDL3jY#O8PWEjqHRj3LGTq0cT0rLNT4T$0zL03CBWG7K0Xc" +
		"1eUfKyNSx5s40r7WTYaa5VKt08fWUg6PY9MGQgsJWSHmIget0qZZ5G$HF7uuH0TI9Emga6g" +
		"Zau7MS4gZDnDiunK9sByt1#eBe02x3GG7KXBiB5WUfIN8BB35INuqfS7QYkmNMumK2r63VZ" +
		"ja2r14knp41r5vRZta1rFnx42WFLmtWKZmUg9$4qLXgediNpM1seNi8hM6kWUWrlO7sWUWV" +
		"luNq3rOVu35y6gg$n3JORgBx35cmDLDlmFRORg7x4J$WrKEt43fWysJ94ZeW5pwXykLFiPg" +
		"2gAgh97O5g3r5Br3PGrP6$Yxq2LGEvKUnZe6eaYaJZGDL458jz3LJDH7FH8b2r5Xr5EmDLH" +
		"r4YEWQg3gAJw6oWwkxe0jLWqKlqCUghlzPNYHZ4N7fLYJX030bKfMAO666W6WddyA#DlT50" +
		"s16LkzyHzSGePE0Ex8CYD17r0R4t84yMzP29OZH32xH26xH32JfYFtfq4LNG3VixZlHtpiD" +
		"GYk4OWP$L3iexmtDKPxzDWgFyW8ubT7GYREgUIwYTAXgAjhgVw6VezpwwKA$vCNSeHzMGd3" +
		"e#e0PtMdSc#h6c2wfxVgpt$FxXpksdPVe1ln39$LHyv0VmRvwFXNTuJjxUqFTx28$WCVY7c" +
		"T$95Uo7$yBlj7BwEUinDyaLM9VNIoRz5Yd7Qc9tL2LNqHpT6b53Mmi4gvHknDuPk55JXLSu" +
		"VAJsyyRg#ztkdhsn#dxXkVEE9$0Kdi4gF8SNy29UnXgMlKgy7fd1ZrBEe6by8J#HUaKC$SH" +
		"#oYkynfwNxrYU4Qj3TD4YTF9r4oBCIXwXo5OZ3bP356hz1uxkaJ1cULxQEGmVQVpAciE$dL" +
		"$uMl4E$rhnZbsxOlvkVd$szVqx#LNasbPKN1KLqwx7u$GSZQVidfq#eZsNrOStjd0VPVNWZ" +
		"I7SGsf$V#Pq$tGpDp$a$YzLUZtsm3oS9RUfDleHQQFLRCAj#05NO3SKU0LA7n#9SyJR#2Fn" +
		"wi8pvTNv8$7h$17gA#MFq6D$XFf8$H7w71tF$D1uekDRXmru4s$Z0xoBZVWOduJKqJ5h#UZ" +
		"iCVzMajxIvSFHH6QuZFpyK3wwij$kuYpuFf53VfCsZiJvAr#9SxmLxT#mf3A6oXWgOp29eV" +
		"p7M$n2bW4BDZBvhIORESX57aQuVzafv9EW2dR7U4p0WQZ1PygUgCbdV6q#vVyAgXZo#QJxw" +
		"wdweJztAEbLJhkYGBK$qmSOg2oCnRX0bUVcJ5JE9wvoFkbLZdTSvUHCLCKOYc61QZJ6eAs1" +
		"wc3cfuTKC52rTrlggcx$CrK7Vje5gbBtarxbjVkZL9Q1gWtRJGvKhNWTJZHGjUAdF14MiSH" +
		"NjN7pwLMssz9N5RdvylHbEeVwAhSpKhKBgV8mq332oPn5NpMHyGuoKcLYSA1gpK#caQeFy$" +
		"5nzJ2Q#U7knrTvkR#6geZFCr$LctcJzRBTkoE#NhsD#d9cEgxAnBv6LrJBaChcqz1alOhSb" +
		"l4xfQtX$GNj$fh6jvV9SwC8NKCHMaPzTGtTbKMiCr4vVwFAr9xOfKOpN#JgV5LV76BOLv7M" +
		"Lx6RCtdh5OMUXqL6VPLA7e7AQH4TbxS7ANN$sZS5LL4DrJ6JciE8sIoVXBhypbyFUwC#6g0" +
		"Xl$KteaTZbZTbJ7HaEyUt8pfXFtIcX#VedbddENfdlqsYOmaTY#deE7LnpyNKjaOllairF#" +
		"QC$QZN$9XhHVGYKiR7dBFJAaxqOqrZJ5L#nN4$ddkMvUVK4qdz$FYy#VFzoevFjVX3$8BMv" +
		"V33aFBvkUlH9ubViLeFVorcy4bqA7cMvkZLTDTZ2ten735QfufGXevAly2ls7IDTot2e9qM" +
		"ePigZlgXROfhiBldfursG3J289SG8P$kXX6Q#PcFkDAlqg$Ix$$5xy$ezSVvkFkbg4#5AjJ" +
		"R9goeiFR1cq9ld#vDOOLQvwbIVmyEhqr84McZrHJpsrmpD4SBj5GbRSCZSLD1c#0DwuqoF7" +
		"Bl7Up7vk#m$17gy#wxU0g$fJulVakV8#Fnyl7$NX6PWuHlAY5rPCnwFZfx$5xP9B6tTFb8D" +
		"D4PJfbNFdu#wjDX5sT1#SZ8WGvfuqZyfbUk4jUrIKB$HYMLCLJ6K1c3IGpHDkQ7y#iACVfq" +
		"zmzvcVLuSdvdyOvRW#m1J7$8#db0tWla1Lwxs0aE#s1#BkjkyD9YCVCtn#l4BJpLfjTvv1A" +
		"l3AMAPoi#XpW6tkzO5n2F0LcdajUHhoPl8pz3hmB6s8RSb3oUt8VCsCHaybBoIOpp6$Abv5" +
		"$9oydpoI#Inv8$8nU1amVaRYJN8L#aZoKyhepcYgiG7TX79ZCSJqOjeX5WxqYXQq6qLEdXY" +
		"WzNF5$nJOeVfs$BY7uaSHmnX5ZF#Z6g$41Y8N4GyJtBvwZoOudBYLc0LSZosrGvvppZ3k9C" +
		"bXUpV8rNRlLb#aVo5CuhrzmwMRM$WkdBk5RtCdqTq$SmlO5filKIa2EOle$WDP5nC$4eop#" +
		"dHtyulxj1ncl4H$JUZVm4vuVjSzYlLOFrZx3iLMABwckhYcKljgjBZoDvtTpFSgvrx55Lnx" +
		"MsExAESMNiOBucwmRH$oZob$GUJjxcjOtzvd6#hRWPtDynvxSdhoHteyzNPCQQNPLy1BaB#" +
		"NZwCUvyNiEPlv3FPRi6P5uxMUmhd#EASJpvJvEhaPrhwNhoLZ9ZpkTrbjSTAB3876z1Fg#f" +
		"5U7rB6YdkAlYVeg7AkPQPpqPrbXNkByAHworbnUABLB178wTrxfr2V4wmN5QdBjCpfLrBUj" +
		"vpUVmNhAuLjOhp2zY7NNM6lfmJcETc5vBy1goHx3lBvJt#$7#SrPhiMoYhYtHasdEkytvYC" +
		"qaLsT#2vbpcTMRp1lBvdqHuxpON7SxbnfUmtbyfbXSFpj6SAvithSsvpc7SvZBUydcE3FxU" +
		"ttP0md6PpSaEXDJLJclURiNqPKOHHpl$QfQp6Pw0d4AFPgJ9nAyHsodV97IybhDPim5AyYT" +
		"ukEoUN$OomZEbtqqlVWSiYycLj6h7VbMuZbY2N4dmRcqUStRJn6yldETU9udU8$a7aRcCzB" +
		"UpZwcQdtShwLNwclCH#n3yJeq2gz$La4udzald1SNA5RFPB5GyMB5DofMpncnHF7jYfSgLl" +
		"UQU4pnuugVKRnIyIh5RojUftYzuesAWsie7TXMtRlYCwriStfTHg7YQeghAwwXk4aQVQiKv" +
		"NrJb4zAKJvTIyzGVABYaxIwkLfwdfQ#D8NltOflrChKUcMiJgP9ul6fn#YXU89MztMuhRr2" +
		"bUzKB3ss$Fi$Kt6Mucp5jHJNLbn7SNt53HGtLDnUiTe7M1qKTr6idezMDyN359ScZizIxrL" +
		"BlHkjiOh7APuLrNZbu3u2nwasCpI$OvAtj#OfNXWkjpTedgk9HPfcMJAl9B7yfEVvF7X3yr" +
		"yRgTkiwNOIkKbYtHx9RpA98wmH3RHq7IsjrifMxovxiCuH3xzkX5OsN4jhyouEryPykPQ#H" +
		"ailrzgFHf93Rf5RvVVo9$cZctlFFM#MFxZyBi5Lbto3owU89ma#lILtNf8xJSadkkJkH3vC" +
		"y6ql#PQGV6F91ua72BvP9T#aahiYUOzSAzV8L#JByYN9dO1S7OdZ1Jb7dYPFbQUuERuR9Dy" +
		"VybbY5R7IBLqkxvPtQPexjVGTMdgPbbwgfTr$dINVSSyRtFFwP7FYrgmBKcyJmIy1vPl46m" +
		"cjVoOM4pSGtED8xW4bznFo6eBxS7aLSIN1lOdaVbDohoYvrvRSXqY#D#L51FSQya9YeLmYR" +
		"vDyWyfR2Bw1vKs4#o$Lv09vWJnVzSdzYppJJPqHYMPUYZ5njoPVbMV9N#HtSdkgaITL$Yf$" +
		"S$b3hUohK8iltVCNxlaJufoWvcpf$avQyZk4tEIcFdVF7xldJztpkUvP$O9QEl$gxMpCvlU" +
		"psOWf568IlxrDugDr2daAUHJPmLHYWeiCS9zF28mdPhZ8SFvTA24mYvZ6xttJ#Crl6hsd8O" +
		"#8QLn0568csysaZliIGk0WOWJxIqG1aKdOYhE9695FPA2KkkHmwdAqj0whWk7tcPM0uIoF8" +
		"oC2guBXzJCTpl$PnC8Xn1Zcnv17S#x6CUtysd2iYnnCPjx1n0X6$WVjBQkH");

	private final Action[] actions;

	public Parser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] unit = defs.v P_INV COLON exprs.r MEMSIZE COLON NUM.n statements.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final ArrayList _list_v = (ArrayList) _symbol_v.value;
					final Definition[] v = _list_v == null ? new Definition[0] : (Definition[]) _list_v.toArray(new Definition[_list_v.size()]);
					final Symbol _symbol_r = _symbols[offset + 4];
					final ArrayList _list_r = (ArrayList) _symbol_r.value;
					final Expression[] r = _list_r == null ? new Expression[0] : (Expression[]) _list_r.toArray(new Expression[_list_r.size()]);
					final Symbol _symbol_n = _symbols[offset + 7];
					final Integer n = (Integer) _symbol_n.value;
					final Symbol _symbol_s = _symbols[offset + 8];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final Statement[] s = _list_s == null ? new Statement[0] : (Statement[]) _list_s.toArray(new Statement[_list_s.size()]);
					 return new Parsed(v, r, s, n);
				}
			},
			new Action() {	// [1] unit = defs.v P_INV COLON exprs.r GAMMA_0 COLON gamma_mappings.f MEMSIZE COLON NUM.n statements.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final ArrayList _list_v = (ArrayList) _symbol_v.value;
					final Definition[] v = _list_v == null ? new Definition[0] : (Definition[]) _list_v.toArray(new Definition[_list_v.size()]);
					final Symbol _symbol_r = _symbols[offset + 4];
					final ArrayList _list_r = (ArrayList) _symbol_r.value;
					final Expression[] r = _list_r == null ? new Expression[0] : (Expression[]) _list_r.toArray(new Expression[_list_r.size()]);
					final Symbol _symbol_f = _symbols[offset + 7];
					final ArrayList _list_f = (ArrayList) _symbol_f.value;
					final GammaMapping[] f = _list_f == null ? new GammaMapping[0] : (GammaMapping[]) _list_f.toArray(new GammaMapping[_list_f.size()]);
					final Symbol _symbol_n = _symbols[offset + 10];
					final Integer n = (Integer) _symbol_n.value;
					final Symbol _symbol_s = _symbols[offset + 11];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final Statement[] s = _list_s == null ? new Statement[0] : (Statement[]) _list_s.toArray(new Statement[_list_s.size()]);
					 return new Parsed(v, r, f, s, n);
				}
			},
			new Action() {	// [2] unit = defs.v P_INV COLON exprs.r P_0 COLON exprs.p MEMSIZE COLON NUM.n statements.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final ArrayList _list_v = (ArrayList) _symbol_v.value;
					final Definition[] v = _list_v == null ? new Definition[0] : (Definition[]) _list_v.toArray(new Definition[_list_v.size()]);
					final Symbol _symbol_r = _symbols[offset + 4];
					final ArrayList _list_r = (ArrayList) _symbol_r.value;
					final Expression[] r = _list_r == null ? new Expression[0] : (Expression[]) _list_r.toArray(new Expression[_list_r.size()]);
					final Symbol _symbol_p = _symbols[offset + 7];
					final ArrayList _list_p = (ArrayList) _symbol_p.value;
					final Expression[] p = _list_p == null ? new Expression[0] : (Expression[]) _list_p.toArray(new Expression[_list_p.size()]);
					final Symbol _symbol_n = _symbols[offset + 10];
					final Integer n = (Integer) _symbol_n.value;
					final Symbol _symbol_s = _symbols[offset + 11];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final Statement[] s = _list_s == null ? new Statement[0] : (Statement[]) _list_s.toArray(new Statement[_list_s.size()]);
					 return new Parsed(v, r, p, s, n);
				}
			},
			new Action() {	// [3] unit = defs.v P_INV COLON exprs.r P_0 COLON exprs.p GAMMA_0 COLON gamma_mappings.f statements.s MEMSIZE COLON NUM.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final ArrayList _list_v = (ArrayList) _symbol_v.value;
					final Definition[] v = _list_v == null ? new Definition[0] : (Definition[]) _list_v.toArray(new Definition[_list_v.size()]);
					final Symbol _symbol_r = _symbols[offset + 4];
					final ArrayList _list_r = (ArrayList) _symbol_r.value;
					final Expression[] r = _list_r == null ? new Expression[0] : (Expression[]) _list_r.toArray(new Expression[_list_r.size()]);
					final Symbol _symbol_p = _symbols[offset + 7];
					final ArrayList _list_p = (ArrayList) _symbol_p.value;
					final Expression[] p = _list_p == null ? new Expression[0] : (Expression[]) _list_p.toArray(new Expression[_list_p.size()]);
					final Symbol _symbol_f = _symbols[offset + 10];
					final ArrayList _list_f = (ArrayList) _symbol_f.value;
					final GammaMapping[] f = _list_f == null ? new GammaMapping[0] : (GammaMapping[]) _list_f.toArray(new GammaMapping[_list_f.size()]);
					final Symbol _symbol_s = _symbols[offset + 11];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final Statement[] s = _list_s == null ? new Statement[0] : (Statement[]) _list_s.toArray(new Statement[_list_s.size()]);
					final Symbol _symbol_n = _symbols[offset + 14];
					final Integer n = (Integer) _symbol_n.value;
					 return new Parsed(v, r, p, f, s, n);
				}
			},
			new Action() {	// [4] exprs = expr
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [5] exprs = exprs COMMA expr
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [6] rgexprs = rgexpr
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [7] rgexprs = rgexprs COMMA rgexpr
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [8] statement = SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return Block.empty();
				}
			},
			Action.RETURN,	// [9] statement = statement1
			Action.RETURN,	// [10] statement2 = statement1
			new Action() {	// [11] lst$statement = statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [12] lst$statement = lst$statement statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [13] opt$lst$statement = 
			Action.RETURN,	// [14] opt$lst$statement = lst$statement
			Action.RETURN,	// [15] statements = opt$lst$statement
			new Action() {	// [16] lst$statement2 = statement2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [17] lst$statement2 = lst$statement2 statement2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [18] opt$lst$statement2 = 
			Action.RETURN,	// [19] opt$lst$statement2 = lst$statement2
			Action.RETURN,	// [20] statements2 = opt$lst$statement2
			new Action() {	// [21] definition = LOCAL ID.n COLON SIZE COLON NUM.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_s = _symbols[offset + 6];
					final Integer s = (Integer) _symbol_s.value;
					 return new LocalVarDef(n, s);
				}
			},
			new Action() {	// [22] definition = GLOBAL ID.n COLON SIZE COLON NUM.s lpred.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_s = _symbols[offset + 6];
					final Integer s = (Integer) _symbol_s.value;
					final Symbol _symbol_l = _symbols[offset + 7];
					final Expression l = (Expression) _symbol_l.value;
					 return new GlobalVarDef(n, s, l);
				}
			},
			new Action() {	// [23] definition = GLOBAL ID.n COLON SIZE COLON NUM.s lpredr.r lpredg.g
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_s = _symbols[offset + 6];
					final Integer s = (Integer) _symbol_s.value;
					final Symbol _symbol_r = _symbols[offset + 7];
					final Expression r = (Expression) _symbol_r.value;
					final Symbol _symbol_g = _symbols[offset + 8];
					final Expression g = (Expression) _symbol_g.value;
					 return new GlobalVarDef(n, s, r, g);
				}
			},
			new Action() {	// [24] definition = GLOBAL ID.n COLON SIZE COLON NUM.s lpred.l R_VAR COLON rvars.rv
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_s = _symbols[offset + 6];
					final Integer s = (Integer) _symbol_s.value;
					final Symbol _symbol_l = _symbols[offset + 7];
					final Expression l = (Expression) _symbol_l.value;
					final Symbol _symbol_rv = _symbols[offset + 10];
					final ArrayList _list_rv = (ArrayList) _symbol_rv.value;
					final Relation[] rv = _list_rv == null ? new Relation[0] : (Relation[]) _list_rv.toArray(new Relation[_list_rv.size()]);
					 return new GlobalVarDef(n, s, l, rv);
				}
			},
			new Action() {	// [25] definition = GLOBAL ID.n COLON SIZE COLON NUM.s lpredr.r lpredg.g R_VAR COLON rvars.rv
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_s = _symbols[offset + 6];
					final Integer s = (Integer) _symbol_s.value;
					final Symbol _symbol_r = _symbols[offset + 7];
					final Expression r = (Expression) _symbol_r.value;
					final Symbol _symbol_g = _symbols[offset + 8];
					final Expression g = (Expression) _symbol_g.value;
					final Symbol _symbol_rv = _symbols[offset + 11];
					final ArrayList _list_rv = (ArrayList) _symbol_rv.value;
					final Relation[] rv = _list_rv == null ? new Relation[0] : (Relation[]) _list_rv.toArray(new Relation[_list_rv.size()]);
					 return new GlobalVarDef(n, s, r, g, rv);
				}
			},
			new Action() {	// [26] definition = GLOBAL ID.n COLON SIZE COLON NUM.s lpred.l G_VAR COLON rvars.gv
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_s = _symbols[offset + 6];
					final Integer s = (Integer) _symbol_s.value;
					final Symbol _symbol_l = _symbols[offset + 7];
					final Expression l = (Expression) _symbol_l.value;
					final Symbol _symbol_gv = _symbols[offset + 10];
					final ArrayList _list_gv = (ArrayList) _symbol_gv.value;
					final Relation[] gv = _list_gv == null ? new Relation[0] : (Relation[]) _list_gv.toArray(new Relation[_list_gv.size()]);
					 return new GlobalVarDef(n, s, gv, l);
				}
			},
			new Action() {	// [27] definition = GLOBAL ID.n COLON SIZE COLON NUM.s lpredr.r lpredg.g G_VAR COLON rvars.gv
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_s = _symbols[offset + 6];
					final Integer s = (Integer) _symbol_s.value;
					final Symbol _symbol_r = _symbols[offset + 7];
					final Expression r = (Expression) _symbol_r.value;
					final Symbol _symbol_g = _symbols[offset + 8];
					final Expression g = (Expression) _symbol_g.value;
					final Symbol _symbol_gv = _symbols[offset + 11];
					final ArrayList _list_gv = (ArrayList) _symbol_gv.value;
					final Relation[] gv = _list_gv == null ? new Relation[0] : (Relation[]) _list_gv.toArray(new Relation[_list_gv.size()]);
					 return new GlobalVarDef(n, s, gv, r, g);
				}
			},
			new Action() {	// [28] definition = GLOBAL ID.n COLON SIZE COLON NUM.s lpred.l R_VAR COLON rvars.rv G_VAR COLON rvars.gv
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_s = _symbols[offset + 6];
					final Integer s = (Integer) _symbol_s.value;
					final Symbol _symbol_l = _symbols[offset + 7];
					final Expression l = (Expression) _symbol_l.value;
					final Symbol _symbol_rv = _symbols[offset + 10];
					final ArrayList _list_rv = (ArrayList) _symbol_rv.value;
					final Relation[] rv = _list_rv == null ? new Relation[0] : (Relation[]) _list_rv.toArray(new Relation[_list_rv.size()]);
					final Symbol _symbol_gv = _symbols[offset + 13];
					final ArrayList _list_gv = (ArrayList) _symbol_gv.value;
					final Relation[] gv = _list_gv == null ? new Relation[0] : (Relation[]) _list_gv.toArray(new Relation[_list_gv.size()]);
					 return new GlobalVarDef(n, s, l, rv, gv);
				}
			},
			new Action() {	// [29] definition = GLOBAL ID.n COLON SIZE COLON NUM.s lpredr.r lpredg.g R_VAR COLON rvars.rv G_VAR COLON rvars.gv
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_s = _symbols[offset + 6];
					final Integer s = (Integer) _symbol_s.value;
					final Symbol _symbol_r = _symbols[offset + 7];
					final Expression r = (Expression) _symbol_r.value;
					final Symbol _symbol_g = _symbols[offset + 8];
					final Expression g = (Expression) _symbol_g.value;
					final Symbol _symbol_rv = _symbols[offset + 11];
					final ArrayList _list_rv = (ArrayList) _symbol_rv.value;
					final Relation[] rv = _list_rv == null ? new Relation[0] : (Relation[]) _list_rv.toArray(new Relation[_list_rv.size()]);
					final Symbol _symbol_gv = _symbols[offset + 14];
					final ArrayList _list_gv = (ArrayList) _symbol_gv.value;
					final Relation[] gv = _list_gv == null ? new Relation[0] : (Relation[]) _list_gv.toArray(new Relation[_list_gv.size()]);
					 return new GlobalVarDef(n, s, r, g, rv, gv);
				}
			},
			new Action() {	// [30] lst$definition = definition
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [31] lst$definition = lst$definition definition
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [32] opt$lst$definition = 
			Action.RETURN,	// [33] opt$lst$definition = lst$definition
			Action.RETURN,	// [34] defs = opt$lst$definition
			new Action() {	// [35] statement1 = LBRACE statements2.ss RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ss = _symbols[offset + 2];
					final ArrayList _list_ss = (ArrayList) _symbol_ss.value;
					final Statement[] ss = _list_ss == null ? new Statement[0] : (Statement[]) _list_ss.toArray(new Statement[_list_ss.size()]);
					 return new Block(ss);
				}
			},
			new Action() {	// [36] statement1 = BV32.n ASG expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new Assignment(n, 32, b);
				}
			},
			new Action() {	// [37] statement1 = BV64.n ASG expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new Assignment(n, 64, b);
				}
			},
			new Action() {	// [38] statement1 = BV1.n ASG expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new Assignment(n, 1, b);
				}
			},
			new Action() {	// [39] statement1 = ID.n ASG expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new Assignment(n, b);
				}
			},
			new Action() {	// [40] statement1 = MEM ASG MEM WITH LBRACK expr.e2 COMMA endian RBRACK COLON nat.n LARROW expr.e3
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e2 = _symbols[offset + 6];
					final Expression e2 = (Expression) _symbol_e2.value;
					final Symbol _symbol_n = _symbols[offset + 11];
					final Nat n = (Nat) _symbol_n.value;
					final Symbol _symbol_e3 = _symbols[offset + 13];
					final Expression e3 = (Expression) _symbol_e3.value;
					 return new Store(e2, e3, n);
				}
			},
			new Action() {	// [41] statement1 = SPECIAL LPAREN FENCE ISH RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return Fence.self();
				}
			},
			new Action() {	// [42] statement1 = SPECIAL LPAREN RET RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return Return.self();
				}
			},
			new Action() {	// [43] statement1 = IF LPAREN expr.a RPAREN statement.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Statement b = (Statement) _symbol_b.value;
					 return new If(a, b);
				}
			},
			new Action() {	// [44] statement1 = IF LPAREN expr.a RPAREN statement.b ELSE statement.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Statement b = (Statement) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 7];
					final Statement c = (Statement) _symbol_c.value;
					 return new If(a, b, c);
				}
			},
			new Action() {	// [45] statement1 = WHILE LPAREN expr.a RPAREN INVARIANT COLON rgexprs.i GAMMA COLON gamma_mappings.g statement.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_i = _symbols[offset + 7];
					final ArrayList _list_i = (ArrayList) _symbol_i.value;
					final Expression[] i = _list_i == null ? new Expression[0] : (Expression[]) _list_i.toArray(new Expression[_list_i.size()]);
					final Symbol _symbol_g = _symbols[offset + 10];
					final ArrayList _list_g = (ArrayList) _symbol_g.value;
					final GammaMapping[] g = _list_g == null ? new GammaMapping[0] : (GammaMapping[]) _list_g.toArray(new GammaMapping[_list_g.size()]);
					final Symbol _symbol_b = _symbols[offset + 11];
					final Statement b = (Statement) _symbol_b.value;
					 return new While(a, i, g, b);
				}
			},
			new Action() {	// [46] statement1 = DO INVARIANT COLON rgexprs.i GAMMA COLON gamma_mappings.g statement.b WHILE LPAREN expr.a RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayList _list_i = (ArrayList) _symbol_i.value;
					final Expression[] i = _list_i == null ? new Expression[0] : (Expression[]) _list_i.toArray(new Expression[_list_i.size()]);
					final Symbol _symbol_g = _symbols[offset + 7];
					final ArrayList _list_g = (ArrayList) _symbol_g.value;
					final GammaMapping[] g = _list_g == null ? new GammaMapping[0] : (GammaMapping[]) _list_g.toArray(new GammaMapping[_list_g.size()]);
					final Symbol _symbol_b = _symbols[offset + 8];
					final Statement b = (Statement) _symbol_b.value;
					final Symbol _symbol_a = _symbols[offset + 11];
					final Expression a = (Expression) _symbol_a.value;
					 return new DoWhile(a, i, g, b);
				}
			},
			new Action() {	// [47] statement1 = error SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return Malformed.self();
				}
			},
			Action.RETURN,	// [48] expr = PREFIX
			Action.RETURN,	// [49] expr = POSTFIX
			new Action() {	// [50] expr = BV32.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					 return new Var(n, 32);
				}
			},
			new Action() {	// [51] expr = BV64.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					 return new Var(n, 64);
				}
			},
			new Action() {	// [52] expr = BV1.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					 return new Var(n, 1);
				}
			},
			new Action() {	// [53] expr = ID.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					 return new Id(n);
				}
			},
			new Action() {	// [54] expr = GOT ID.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					 return new GOTAccess(new Id(n));
				}
			},
			new Action() {	// [55] expr = MEM LBRACK expr.i COMMA endian RBRACK COLON nat.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_i = _symbols[offset + 3];
					final Expression i = (Expression) _symbol_i.value;
					final Symbol _symbol_n = _symbols[offset + 8];
					final Nat n = (Nat) _symbol_n.value;
					 return new Access(i, n);
				}
			},
			new Action() {	// [56] expr = NUM.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final Integer n = (Integer) _symbol_n.value;
					 return new Lit(n);
				}
			},
			new Action() {	// [57] expr = PLUS expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expression a = (Expression) _symbol_a.value;
					 return new PreOp("+", a);
				}
			},
			new Action() {	// [58] expr = MINUS expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expression a = (Expression) _symbol_a.value;
					 return new PreOp("-", a);
				}
			},
			new Action() {	// [59] expr = BANG expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expression a = (Expression) _symbol_a.value;
					 return new PreOp("!", a);
				}
			},
			new Action() {	// [60] expr = TILDE expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expression a = (Expression) _symbol_a.value;
					 return new PreOp("~", a);
				}
			},
			new Action() {	// [61] expr = expr.a STAR expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("*", a, b);
				}
			},
			new Action() {	// [62] expr = expr.a DIV expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("/", a, b);
				}
			},
			new Action() {	// [63] expr = expr.a MOD expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("%", a, b);
				}
			},
			new Action() {	// [64] expr = expr.a PLUS expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("+", a, b);
				}
			},
			new Action() {	// [65] expr = expr.a MINUS expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("-", a, b);
				}
			},
			new Action() {	// [66] expr = expr.a SHL expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("<<",a, b);
				}
			},
			new Action() {	// [67] expr = expr.a SHR expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp(">>",a, b);
				}
			},
			new Action() {	// [68] expr = expr.a ASHR expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp(">>>",a, b);
				}
			},
			new Action() {	// [69] expr = expr.a LT expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("<", a, b);
				}
			},
			new Action() {	// [70] expr = expr.a LE expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("<=",a, b);
				}
			},
			new Action() {	// [71] expr = expr.a GE expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp(">=",a, b);
				}
			},
			new Action() {	// [72] expr = expr.a GT expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp(">", a, b);
				}
			},
			new Action() {	// [73] expr = expr.a EQ expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("==",a, b);
				}
			},
			new Action() {	// [74] expr = expr.a NEQ expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("!=",a, b);
				}
			},
			new Action() {	// [75] expr = expr.a AMP expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("&", a, b);
				}
			},
			new Action() {	// [76] expr = expr.a CARET expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("^", a, b);
				}
			},
			new Action() {	// [77] expr = expr.a PIPE expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("|", a, b);
				}
			},
			new Action() {	// [78] expr = expr.a AND expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("&&",a, b);
				}
			},
			new Action() {	// [79] expr = expr.a OR expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("||",a, b);
				}
			},
			new Action() {	// [80] expr = LPAREN expr.e RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 return (Symbol) e;
				}
			},
			new Action() {	// [81] expr = TRUE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Const("True");
				}
			},
			new Action() {	// [82] expr = FALSE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Const("False");
				}
			},
			new Action() {	// [83] expr = LOW COLON NUM.n LBRACK expr.e RBRACK
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 3];
					final Integer n = (Integer) _symbol_n.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					 return new ExtLow(n, e);
				}
			},
			new Action() {	// [84] expr = HIGH COLON NUM.n LBRACK expr.e RBRACK
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 3];
					final Integer n = (Integer) _symbol_n.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					 return new ExtHigh(n, e);
				}
			},
			new Action() {	// [85] expr = SIGNED COLON NUM.n LBRACK expr.e RBRACK
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 3];
					final Integer n = (Integer) _symbol_n.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					 return new ExtSigned(n, e);
				}
			},
			new Action() {	// [86] expr = UNSIGNED COLON NUM.n LBRACK expr.e RBRACK
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 3];
					final Integer n = (Integer) _symbol_n.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expression e = (Expression) _symbol_e.value;
					 return new ExtUnsigned(n, e);
				}
			},
			new Action() {	// [87] expr = IF expr.e1 THEN expr.e2 ELSE expr.e3
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e1 = _symbols[offset + 2];
					final Expression e1 = (Expression) _symbol_e1.value;
					final Symbol _symbol_e2 = _symbols[offset + 4];
					final Expression e2 = (Expression) _symbol_e2.value;
					final Symbol _symbol_e3 = _symbols[offset + 6];
					final Expression e3 = (Expression) _symbol_e3.value;
					 return new IfThenElse(e1, e2, e3);
				}
			},
			new Action() {	// [88] rgexpr = ID.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					 return new Id(n);
				}
			},
			new Action() {	// [89] rgexpr = PRIMEID.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					 return new Id(n);
				}
			},
			new Action() {	// [90] rgexpr = NUM.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final Integer n = (Integer) _symbol_n.value;
					 return new Lit(n);
				}
			},
			new Action() {	// [91] rgexpr = PLUS rgexpr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expression a = (Expression) _symbol_a.value;
					 return new PreOp("+", a);
				}
			},
			new Action() {	// [92] rgexpr = MINUS rgexpr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expression a = (Expression) _symbol_a.value;
					 return new PreOp("-", a);
				}
			},
			new Action() {	// [93] rgexpr = BANG rgexpr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expression a = (Expression) _symbol_a.value;
					 return new PreOp("!", a);
				}
			},
			new Action() {	// [94] rgexpr = TILDE rgexpr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expression a = (Expression) _symbol_a.value;
					 return new PreOp("~", a);
				}
			},
			new Action() {	// [95] rgexpr = rgexpr.a STAR rgexpr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("*", a, b);
				}
			},
			new Action() {	// [96] rgexpr = rgexpr.a DIV rgexpr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("/", a, b);
				}
			},
			new Action() {	// [97] rgexpr = rgexpr.a MOD rgexpr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("%", a, b);
				}
			},
			new Action() {	// [98] rgexpr = rgexpr.a PLUS rgexpr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("+", a, b);
				}
			},
			new Action() {	// [99] rgexpr = rgexpr.a MINUS rgexpr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("-", a, b);
				}
			},
			new Action() {	// [100] rgexpr = rgexpr.a SHL rgexpr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("<<",a, b);
				}
			},
			new Action() {	// [101] rgexpr = rgexpr.a SHR rgexpr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp(">>",a, b);
				}
			},
			new Action() {	// [102] rgexpr = rgexpr.a ASHR rgexpr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp(">>>",a, b);
				}
			},
			new Action() {	// [103] rgexpr = rgexpr.a LT rgexpr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("<", a, b);
				}
			},
			new Action() {	// [104] rgexpr = rgexpr.a LE rgexpr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("<=",a, b);
				}
			},
			new Action() {	// [105] rgexpr = rgexpr.a GE rgexpr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp(">=",a, b);
				}
			},
			new Action() {	// [106] rgexpr = rgexpr.a GT rgexpr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp(">", a, b);
				}
			},
			new Action() {	// [107] rgexpr = rgexpr.a EQ rgexpr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("==",a, b);
				}
			},
			new Action() {	// [108] rgexpr = rgexpr.a NEQ rgexpr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("!=",a, b);
				}
			},
			new Action() {	// [109] rgexpr = rgexpr.a AMP rgexpr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("&", a, b);
				}
			},
			new Action() {	// [110] rgexpr = rgexpr.a CARET rgexpr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("^", a, b);
				}
			},
			new Action() {	// [111] rgexpr = rgexpr.a PIPE rgexpr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("|", a, b);
				}
			},
			new Action() {	// [112] rgexpr = rgexpr.a AND rgexpr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("&&",a, b);
				}
			},
			new Action() {	// [113] rgexpr = rgexpr.a OR rgexpr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("||",a, b);
				}
			},
			new Action() {	// [114] rgexpr = LPAREN rgexpr.e RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 return (Symbol) e;
				}
			},
			new Action() {	// [115] rgexpr = TRUE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Const("True");
				}
			},
			new Action() {	// [116] rgexpr = FALSE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Const("False");
				}
			},
			new Action() {	// [117] lpred = LPRED COLON expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expression a = (Expression) _symbol_a.value;
					 return (Symbol) a;
				}
			},
			new Action() {	// [118] lpredr = LPREDRELY COLON expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expression a = (Expression) _symbol_a.value;
					 return (Symbol) a;
				}
			},
			new Action() {	// [119] lpredg = LPREDGUAR COLON expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expression a = (Expression) _symbol_a.value;
					 return (Symbol) a;
				}
			},
			new Action() {	// [120] rvars = rvar
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [121] rvars = rvars COMMA rvar
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [122] rvar = LPAREN expr.c COMMA rgexpr.r RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_c = _symbols[offset + 2];
					final Expression c = (Expression) _symbol_c.value;
					final Symbol _symbol_r = _symbols[offset + 4];
					final Expression r = (Expression) _symbol_r.value;
					 return new Relation(c, r);
				}
			},
			new Action() {	// [123] gamma_mappings = gamma_mapping
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [124] gamma_mappings = gamma_mappings COMMA gamma_mapping
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [125] gamma_mapping = ID.n MAPSTO rgexpr.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expression e = (Expression) _symbol_e.value;
					 return new GammaMapping(n, e);
				}
			},
			new Action() {	// [126] gamma_mapping = MEM LBRACK NUM.i RBRACK COLON nat.n MAPSTO rgexpr.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_i = _symbols[offset + 3];
					final Integer i = (Integer) _symbol_i.value;
					final Symbol _symbol_n = _symbols[offset + 6];
					final Nat n = (Nat) _symbol_n.value;
					final Symbol _symbol_e = _symbols[offset + 8];
					final Expression e = (Expression) _symbol_e.value;
					 return new GammaMapping(i, n, e);
				}
			},
			Action.RETURN,	// [127] endian = EL
			Action.RETURN,	// [128] endian = BE
			new Action() {	// [129] nat = U32
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return U32.self();
				}
			},
			new Action() {	// [130] nat = U64
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return U64.self();
				}
			},
			new Action() {	// [131] nat = S32
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return S32.self();
				}
			},
			new Action() {	// [132] nat = S64
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return S64.self();
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
