%package "wemelt";
%class "Parser";

%terminals LOCAL, GLOBAL;
//%terminals ARRAY;

//%terminals RETURN, BREAK, CONTINUE;
%terminals IF, ELSE, WHILE, DO;

%terminals ID;
%terminals NUM;
%terminals TRUE, FALSE;

%terminals LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE;
%terminals POSTFIX;
%terminals PREFIX,  BANG, TILDE;
%terminals STAR, DIV, MOD;
%terminals PLUS, MINUS;
%terminals SHL, SHR, ASHR;
%terminals LT, LE, GE, GT;
%terminals EQ, NEQ;
%terminals AMP;
%terminals CARET;
%terminals PIPE;
%terminals AND;
%terminals OR;
%terminals COLON;
%terminals ASG;
%terminals COMMA, SEMICOLON;

%terminals CAS;
%terminals FENCE, CFENCE;
%terminals INVARIANT, GAMMA, P_0, GAMMA_0;
%terminals P_INV, R_VAR, G_VAR;
%terminals LPRED, LPREDGUAR, LPREDRELY;
%terminals MAPSTO;
%terminals PRIMEID;

%nonassoc IF;
%nonassoc ELSE;
%nonassoc LPAREN, RPAREN;
%right PREFIX;
%left  STAR, DIV, MOD;
%left  PLUS, MINUS;
%left  SHL, SHR, ASHR;
%left  LT, LE, GE, GT;
%left  EQ, NEQ;
%left  AMP;
%left  CARET;
%left  PIPE;
%left  AND;
%left  OR;
%right COLON;
%right ASG;
%left  COMMA;

%typeof ID      = "String";
%typeof PRIMEID      = "String";

%typeof NUM     = "Integer";

%typeof expr    = "Expression";
%typeof rgexpr    = "Expression";

%typeof statement   = "Statement";
%typeof statement1  = "Statement";
%typeof statement2  = "Statement";

%typeof definition = "Definition";
%typeof lpred = "Expression";
%typeof lpredr = "Expression";
%typeof lpredg = "Expression";
%typeof rvar = "Relation";
%typeof unit = "Parsed";
%typeof gamma_mapping = "GammaMapping";
//%typeof lpredindex = "Expression";

%typeof cast = "Cast"

%goal unit;

unit = defs.v P_INV COLON exprs.r statements.s {: return new Parsed(v, r, s); :}
     | defs.v P_INV COLON exprs.r GAMMA_0 COLON gamma_mappings.f statements.s {: return new Parsed(v, r,f, s); :}
     | defs.v P_INV COLON exprs.r P_0 COLON exprs.p statements.s {: return new Parsed(v, r, p, s); :}
     | defs.v P_INV COLON exprs.r P_0 COLON exprs.p GAMMA_0 COLON gamma_mappings.f statements.s {: return new Parsed(v, r, p, f, s); :};

exprs = expr | exprs COMMA expr;
rgexprs = rgexpr | rgexprs COMMA rgexpr;


statement
    = SEMICOLON {: return Block.empty(); :}
    | statement1
    ;

statement2
	=  statement1
    ;

statements  = statement *;
statements2 = statement2 *;

definition
    =     LOCAL ID.n COLON SIZE COLON NUM.s {: return new LocalVarDef(n, s); :}
          | GLOBAL ID.n COLON SIZE COLON NUM.s lpred.l {: return new GlobalVarDef(n, s, l); :}
          | GLOBAL ID.n COLON SIZE COLON NUM.s lpredr.r lpredg.g {: return new GlobalVarDef(n, s, r, g); :}
          | GLOBAL ID.n COLON SIZE COLON NUM.s lpred.l R_VAR COLON rvars.rv {: return new GlobalVarDef(n, s, l, rv); :}
          | GLOBAL ID.n COLON SIZE COLON NUM.s lpredr.r lpredg.g R_VAR COLON rvars.rv {: return new GlobalVarDef(n, s, r, g, rv); :}
          | GLOBAL ID.n COLON SIZE COLON NUM.s lpred.l G_VAR COLON rvars.gv {: return new GlobalVarDef(n, s, gv, l); :}
          | GLOBAL ID.n COLON SIZE COLON NUM.s lpredr.r lpredg.g G_VAR COLON rvars.gv {: return new GlobalVarDef(n, s, gv, r, g); :}
          | GLOBAL ID.n COLON SIZE COLON NUM.s lpred.l R_VAR COLON rvars.rv G_VAR COLON rvars.gv {: return new GlobalVarDef(n, s, l, rv, gv); :}
          | GLOBAL ID.n COLON SIZE COLON NUM.s lpredr.r lpredg.g R_VAR COLON rvars.rv G_VAR COLON rvars.gv {: return new GlobalVarDef(n, s, r, g, rv, gv); :}
          /*
          | ARRAY ID.n LBRACK NUM.s RBRACK COLON lpred.l mode.m {: return new ArrayDef(n, s, l, m); :}
          | ARRAY ID.n LBRACK NUM.s RBRACK COLON lpredindexes.l mode.m {: return new ArrayDef(n, s, l, m); :}
          | ARRAY ID.n LBRACK NUM.s RBRACK COLON mode.m {: return new ArrayDef(n, s, m); :}
          | ARRAY REG_ID.n LBRACK NUM.s RBRACK COLON lpred.l {: return new ArrayDef(n, s, l); :}
          | ARRAY REG_ID.n LBRACK NUM.s RBRACK COLON lpredindexes.l {: return new ArrayDef(n, s, l); :}
          | ARRAY REG_ID.n LBRACK NUM.s RBRACK  {: return new ArrayDef(n, s); :} */
          ;

defs = definition *;

statement1
    = LBRACE statements2.ss RBRACE          {: return new Block(ss); :}
    | BV32.n ASG    expr.b                             {: return new Assignment(n, 32, b);  :}
    | BV64.n ASG    expr.b                             {: return new Assignment(n, 64, b);  :}
    | BV1.n  ASG    expr.b                            {: return new Assignment(n, 1, b);  :}
    | ID.n ASG    expr.b                            {: return new Assignment(n, b);  :}
    | MEM ASG MEM WITH LBRACK expr.e2 COMMA ENDIAN RBRACK COLON NAT LARROW expr.e3 {: return new Store(e2, e2); :}
    | SPECIAL LPAREN FENCE ISH RPAREN                 {: return Fence.self();  :}
    | IF LPAREN expr.a RPAREN statement.b   {: return new If(a, b);  :}
    | IF LPAREN expr.a RPAREN statement.b ELSE statement.c     {: return new If(a, b, c);   :}
    | WHILE LPAREN expr.a RPAREN INVARIANT COLON rgexprs.i GAMMA COLON gamma_mappings.g statement.b      {: return new While(a, i, g, b);   :}
    | DO INVARIANT COLON rgexprs.i GAMMA COLON gamma_mappings.g statement.b WHILE LPAREN expr.a RPAREN    {: return new DoWhile(a, i, g, b);   :}
    | error SEMICOLON {: return Malformed.self(); :}
    ;

expr
    = PREFIX | POSTFIX /* unused */
    | BV32.n                             {: return new Var(n, 32);  :}
    | BV64.n                             {: return new Var(n, 64);  :}
    | BV1.n                             {: return new Var(n, 1);  :}
    | ID.n                              {: return new Id(n);  :}
    | GOT ID.n                              {: return new GOTAccess(new Id(n));  :}
    | MEM LBRACK expr.i COMMA ENDIAN RBRACK COLON NAT      {: return new Access(n, i); :}
    | NUM.n                             {: return new Lit(n); :}
    | PLUS  expr.a @ PREFIX             {: return new PreOp("+", a);    :}
    | MINUS expr.a @ PREFIX             {: return new PreOp("-", a);    :}
    | BANG  expr.a @ PREFIX             {: return new PreOp("!", a);    :}
    | TILDE expr.a @ PREFIX             {: return new PreOp("~", a);    :}
    | expr.a STAR   expr.b              {: return new BinOp("*", a, b); :}
    | expr.a DIV    expr.b              {: return new BinOp("/", a, b); :}
    | expr.a MOD    expr.b              {: return new BinOp("%", a, b); :}
    | expr.a PLUS   expr.b              {: return new BinOp("+", a, b); :}
    | expr.a MINUS  expr.b              {: return new BinOp("-", a, b); :}
    | expr.a SHL    expr.b              {: return new BinOp("<<",a, b); :}
    | expr.a SHR    expr.b              {: return new BinOp(">>",a, b); :}
    | expr.a ASHR    expr.b             {: return new BinOp(">>>",a, b); :}
    | expr.a LT     expr.b              {: return new BinOp("<", a, b); :}
    | expr.a LE     expr.b              {: return new BinOp("<=",a, b); :}
    | expr.a GE     expr.b              {: return new BinOp(">=",a, b); :}
    | expr.a GT     expr.b              {: return new BinOp(">", a, b); :}
    | expr.a EQ     expr.b              {: return new BinOp("==",a, b); :}
    | expr.a NEQ    expr.b              {: return new BinOp("!=",a, b); :}
    | expr.a AMP    expr.b              {: return new BinOp("&", a, b); :}
    | expr.a CARET  expr.b              {: return new BinOp("^", a, b); :}
    | expr.a PIPE   expr.b              {: return new BinOp("|", a, b); :}
    | expr.a AND    expr.b              {: return new BinOp("&&",a, b); :}
    | expr.a OR     expr.b              {: return new BinOp("||",a, b); :}
    | LPAREN expr.e RPAREN              {: return (Symbol) e;           :}
    | TRUE                              {: return new Const("True");  :}
    | FALSE                             {: return new Const("False");  :}
    | LOW COLON NUM.n LBRACK expr.e RBRACK {: return new ExtLow(n, e); :}
    | HIGH COLON NUM.n LBRACK expr.e RBRACK {: return new ExtHigh(n, e); :}
    | SIGNED COLON NUM.n LBRACK expr.e RBRACK {: return new ExtSigned(n, e); :}
    | UNSIGNED COLON NUM.n LBRACK expr.e RBRACK {: return new ExtUnsigned(n, e); :}
    | IF expr.e1 THEN expr.e2 ELSE expr.e3 {: return new Question(e1, e2, e3); :}
    ;

rgexpr = ID.n                              {: return new Id(n);  :}
    | PRIMEID.n                           {: return new Id(n);  :}
    //| ID.n LBRACK rgexpr.i RBRACK       {: return new Access(n, i); :}
    | NUM.n                             {: return new Lit(n); :}
    | PLUS  rgexpr.a @ PREFIX             {: return new PreOp("+", a);    :}
    | MINUS rgexpr.a @ PREFIX             {: return new PreOp("-", a);    :}
    | BANG  rgexpr.a @ PREFIX             {: return new PreOp("!", a);    :}
    | TILDE rgexpr.a @ PREFIX             {: return new PreOp("~", a);    :}
    | rgexpr.a STAR   rgexpr.b              {: return new BinOp("*", a, b); :}
    | rgexpr.a DIV    rgexpr.b              {: return new BinOp("/", a, b); :}
    | rgexpr.a MOD    rgexpr.b              {: return new BinOp("%", a, b); :}
    | rgexpr.a PLUS   rgexpr.b              {: return new BinOp("+", a, b); :}
    | rgexpr.a MINUS  rgexpr.b              {: return new BinOp("-", a, b); :}
    | rgexpr.a SHL    rgexpr.b              {: return new BinOp("<<",a, b); :}
    | rgexpr.a SHR    rgexpr.b              {: return new BinOp(">>",a, b); :}
    | rgexpr.a ASHR   rgexpr.b              {: return new BinOp(">>>",a, b); :}
    | rgexpr.a LT     rgexpr.b              {: return new BinOp("<", a, b); :}
    | rgexpr.a LE     rgexpr.b              {: return new BinOp("<=",a, b); :}
    | rgexpr.a GE     rgexpr.b              {: return new BinOp(">=",a, b); :}
    | rgexpr.a GT     rgexpr.b              {: return new BinOp(">", a, b); :}
    | rgexpr.a EQ     rgexpr.b              {: return new BinOp("==",a, b); :}
    | rgexpr.a NEQ    rgexpr.b              {: return new BinOp("!=",a, b); :}
    | rgexpr.a AMP    rgexpr.b              {: return new BinOp("&", a, b); :}
    | rgexpr.a CARET  rgexpr.b              {: return new BinOp("^", a, b); :}
    | rgexpr.a PIPE   rgexpr.b              {: return new BinOp("|", a, b); :}
    | rgexpr.a AND    rgexpr.b              {: return new BinOp("&&",a, b); :}
    | rgexpr.a OR     rgexpr.b              {: return new BinOp("||",a, b); :}
    | LPAREN rgexpr.e RPAREN              {: return (Symbol) e;           :}
    | TRUE                              {: return new Const("True");  :}
    | FALSE                             {: return new Const("False");  :}
    ;

// for _L(x): pred construction to set predicate for variable security level
lpred = LPRED COLON expr.a {: return (Symbol) a; :};
lpredr = LPREDRELY COLON expr.a {: return (Symbol) a; :};
lpredg = LPREDGUAR COLON expr.a {: return (Symbol) a; :};

rvars = rvar | rvars COMMA rvar;
rvar = LPAREN expr.c COMMA rgexpr.r RPAREN {: return new Relation(c, r); :};

//lpredindex = LPRED LBRACK NUM.n RBRACK COLON expr.a {: return (Symbol) a; :};

//lpredindexes = lpredindex | lpredindexes lpredindex;

gamma_mappings
    = gamma_mapping | gamma_mappings COMMA gamma_mapping;

gamma_mapping
    = ID.n MAPSTO rgexpr.e {: return new GammaMapping(n, e); :}
    //| ID.n LBRACK NUM.i RBRACK MAPSTO expr.e {: return new GammaMapping(n, i, s); :}
    //| ID.n LBRACK STAR RBRACK MAPSTO expr.e {: return new GammaMapping(n, s); :}
    ;

endian = EL | BE;

nat = U32 | U64 | S32 | S64;