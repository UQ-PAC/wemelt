BIL stuff:
-handle substituting m for accesses - do we actually need to? do locals actually matter for m/new_var?
-debug
-handle wzr/xzr properly
-fix substituting accesses

later:
-merging gamma for ambiguous stores
-use if then else to handle branches even in if statements
-CAS and arrays?

to check for memory accesses:
-index is low
-index in bounds
-rules hold for all possible indices

-make P_inv optional in parsing
-remove unnecessary SMT calls in R-var part of P + R ?? - check this ??
-SMT optimisations to reduce calls in a few places

new weak memory model:
-optimise by only testing those variables not in the sets to compare to in AssignG
done:
-I and U updates
-P restrict ind
-D updates in rules
-D subset checks
-P restrict u checks
-u and i calculations
-D fixed point calculation
-all assignG checks
-convert G to being Gvar
-modified P + (R, i) update
-modified gamma update

for later
-make r_var implementation better?
-check rely & guarantee don't evaluate to false initially