package tool;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "Parser.grammar".
 */
public class Parser extends beaver.Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short PLUS = 1;
		static public final short MINUS = 2;
		static public final short ID = 3;
		static public final short LPAREN = 4;
		static public final short REG_ID = 5;
		static public final short PREFIX = 6;
		static public final short POSTFIX = 7;
		static public final short NUM = 8;
		static public final short BANG = 9;
		static public final short TILDE = 10;
		static public final short LOW = 11;
		static public final short HIGH = 12;
		static public final short TRUE = 13;
		static public final short FALSE = 14;
		static public final short STAR = 15;
		static public final short DIV = 16;
		static public final short MOD = 17;
		static public final short SHL = 18;
		static public final short SHR = 19;
		static public final short ASHR = 20;
		static public final short LT = 21;
		static public final short LE = 22;
		static public final short GE = 23;
		static public final short GT = 24;
		static public final short EQ = 25;
		static public final short NEQ = 26;
		static public final short AMP = 27;
		static public final short SEMICOLON = 28;
		static public final short CARET = 29;
		static public final short PIPE = 30;
		static public final short WHILE = 31;
		static public final short IF = 32;
		static public final short LBRACE = 33;
		static public final short FENCE = 34;
		static public final short AND = 35;
		static public final short OR = 36;
		static public final short COLON = 37;
		static public final short RBRACE = 38;
		static public final short COMMA = 39;
		static public final short RPAREN = 40;
		static public final short VAR = 41;
		static public final short MODE = 42;
		static public final short LPRED = 43;
		static public final short INVARIANT = 44;
		static public final short GAMMA = 45;
		static public final short P_0 = 46;
		static public final short GAMMA_0 = 47;
		static public final short ELSE = 48;
		static public final short NORW = 49;
		static public final short NOW = 50;
		static public final short RW = 51;
		static public final short ASG = 52;

		static public final String[] NAMES = {
			"EOF",
			"PLUS",
			"MINUS",
			"ID",
			"LPAREN",
			"REG_ID",
			"PREFIX",
			"POSTFIX",
			"NUM",
			"BANG",
			"TILDE",
			"LOW",
			"HIGH",
			"TRUE",
			"FALSE",
			"STAR",
			"DIV",
			"MOD",
			"SHL",
			"SHR",
			"ASHR",
			"LT",
			"LE",
			"GE",
			"GT",
			"EQ",
			"NEQ",
			"AMP",
			"SEMICOLON",
			"CARET",
			"PIPE",
			"WHILE",
			"IF",
			"LBRACE",
			"FENCE",
			"AND",
			"OR",
			"COLON",
			"RBRACE",
			"COMMA",
			"RPAREN",
			"VAR",
			"MODE",
			"LPRED",
			"INVARIANT",
			"GAMMA",
			"P_0",
			"GAMMA_0",
			"ELSE",
			"NORW",
			"NOW",
			"RW",
			"ASG"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjLrbm5KKKFMyc8OIO844CaOSW#CYYH21v925atp0AA24WiYYB28g02#12921##MLPVgW" +
		"VQcaLdtnOLhc1IrHKH4KH5qH0H1H55445DEtfdZjJyvBtXgJA3uhAl3fpRdVVqtUcP#RUVe" +
		"3z70PY49RX6jo6vUW36vFKIRHYDPhHY7Jqnm1a8Hj3C1J3S1b68e8SvE4kN87HHZkDogimL" +
		"YaquNhKu2RSW6in8q2RvcdJi5XhnNSsKd0VuzuTe4tsjClGrsXJ6RSP2yuULtLusWUmmMXT" +
		"pGMS8KFz7X3tGa#RoSXQsuHRg79dk2X0Ux6d7OnBOk8QZVejG1lstU#bHhk4KVNJkjgSvmH" +
		"eXtlQ9eoWresgTVDmELS$iNQKfyrLVo8V3p6gXIkn4WLOWJ7gvG3jE6gTgAKeYucw5EM1KK" +
		"im0L5KOJmAKOHYJ4G5Qb67UZJqZft7O$fjSJ9G9VfX4jQX3UjHZKPr8k7RSYvTV#zOukSwH" +
		"Ht3TBGmYyp4B6OHtNSZviTzhl7wcep2pIBQdek5k1ct6zjH9FbiHvt8rdwBS2lhrvsuXrLE" +
		"jrTX3Ux5$J5#kgevxLRSORpMua40rn5JYSbm3yShnEmOvHeKSprAkI9b7Cbd7hIvClrPFGQ" +
		"mRWnabHZ4Qf35Ef3DIZ246MyeixhMQkL8vcGmuqz4BkzzEEz#H80snzFcC5DhhUERoqnlyv" +
		"SSe8rusYXjhIrbNBjRSU5fo$cajTRLH3b3b9KZiJRgYnirsZ0ZsxuPUgADlTQUnTLHdQVbd" +
		"BkZ3Hkj6zNHHRdwtOiBef9HgycrH3tHU1Qj6pNQewXQPVERIEP#BeMxf5Jcr3JkSTAHqJjs" +
		"de#vxuVEG6Ev4oiqkHa9tvPpxVfxn#AFZUAlo6IHCBriBvV5Uwxn#i96uMOHRO$XRZv9#Xr" +
		"5WSzsr8bixHVXBuyPJVz3SQf1XDSJZl7JRwFJpcTLqruLYF2VOWrHHpGeESGBsDZ64pkE0t" +
		"OHJLqHnm6XUd8MKKAxcT2#gyZpoRF8AzfCCGwr2ZyY$0HFXUHDvCta5palQtYedSnw7jf9V" +
		"fIyZpo3V9GyXto6l02mKichoOnjZoP7oCLapcbL4xFfcqzUIaudhs6SO#I7oJlrDNG6nnuJ" +
		"VbPui$0MuUrwHH9ezTuZDRQFUoFO$HpRJkFfAPz$1$4L3LwNdIq#N4$hiAdZO1M2dQVTPMm" +
		"cnqxIuFx5BY2c4pRRcUGMGg$xRl6jalYFnrwFFKtwwsZp#TZDqZ#N64RZ1V8Itk9#yc8PMy" +
		"cusV7kMURQHVyTRjjlyyYXDaFioS9JXUS9BnHUBhnMUBtm1k4dXPyHVabug$0sOLa3x17UA" +
		"tn0#A3m8U4J0VTsIlYqmo7BOIjJU70YhUYUZstRBVusr#f8xBZLqNKEErdcsYJSxXlhqodU" +
		"8f$zDD5blavpbtTgr$diARwvolKt63IN#6taNVs8E8VwX$YSs4LyHdnAy0jNdn0V4nyHEuW" +
		"FYUt41yJxn7l4Dk9TuXtYRQ9TVQlsgc$K7lKrM$o6r9V45yHk4#ijzQPwGxskjfhMN#gCEc" +
		"siG#PyN9qo$3rnqBk#xuW3SQzyFx5F$Ql#K7#h7zHXzPFfFQf#DRn5l7unvzVKg#eLzRCwm" +
		"aO3zv0MqPSxsf3PrPQGDNI#BJEmp0wWYlO4eiR0qbyd4U8C8MRn9BCthMJzqNOj#shfexDk" +
		"FUrgOhpPCMleNKOoaKAacNQKurrXTOBzFoCsNZdxAdme$Wz#b3GL");

	private final Action[] actions;

	public Parser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] unit = vardefs.v locals.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final ArrayList _list_v = (ArrayList) _symbol_v.value;
					final VarDef[] v = _list_v == null ? new VarDef[0] : (VarDef[]) _list_v.toArray(new VarDef[_list_v.size()]);
					final Symbol _symbol_s = _symbols[offset + 2];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final Statement[] s = _list_s == null ? new Statement[0] : (Statement[]) _list_s.toArray(new Statement[_list_s.size()]);
					 return new Global(v, s);
				}
			},
			new Action() {	// [1] unit = vardefs.v P_0 COLON exprs.e GAMMA_0 COLON exprs.f locals.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final ArrayList _list_v = (ArrayList) _symbol_v.value;
					final VarDef[] v = _list_v == null ? new VarDef[0] : (VarDef[]) _list_v.toArray(new VarDef[_list_v.size()]);
					final Symbol _symbol_e = _symbols[offset + 4];
					final ArrayList _list_e = (ArrayList) _symbol_e.value;
					final Expression[] e = _list_e == null ? new Expression[0] : (Expression[]) _list_e.toArray(new Expression[_list_e.size()]);
					final Symbol _symbol_f = _symbols[offset + 7];
					final ArrayList _list_f = (ArrayList) _symbol_f.value;
					final Expression[] f = _list_f == null ? new Expression[0] : (Expression[]) _list_f.toArray(new Expression[_list_f.size()]);
					final Symbol _symbol_s = _symbols[offset + 8];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final Statement[] s = _list_s == null ? new Statement[0] : (Statement[]) _list_s.toArray(new Statement[_list_s.size()]);
					 return new Global(v, e, f, s);
				}
			},
			new Action() {	// [2] exprs = expr
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [3] exprs = exprs COMMA expr
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [4] local = SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return Block.empty();
				}
			},
			Action.RETURN,	// [5] local = local1
			Action.RETURN,	// [6] local2 = local1
			new Action() {	// [7] lst$local = local
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [8] lst$local = lst$local local
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [9] opt$lst$local = 
			Action.RETURN,	// [10] opt$lst$local = lst$local
			Action.RETURN,	// [11] locals = opt$lst$local
			new Action() {	// [12] lst$local2 = local2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [13] lst$local2 = lst$local2 local2
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [14] opt$lst$local2 = 
			Action.RETURN,	// [15] opt$lst$local2 = lst$local2
			Action.RETURN,	// [16] locals2 = opt$lst$local2
			new Action() {	// [17] vardef = VAR REG_ID.n SEMICOLON lpred.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_l = _symbols[offset + 4];
					final Expression l = (Expression) _symbol_l.value;
					 return new VarDef(n, l);
				}
			},
			new Action() {	// [18] vardef = VAR REG_ID.n SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					 return new VarDef(n);
				}
			},
			new Action() {	// [19] vardef = VAR ID.n SEMICOLON lpred.l mode.m
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_l = _symbols[offset + 4];
					final Expression l = (Expression) _symbol_l.value;
					final Symbol _symbol_m = _symbols[offset + 5];
					final Mode m = (Mode) _symbol_m.value;
					  return new VarDef(n, l, m);
				}
			},
			new Action() {	// [20] vardef = VAR ID.n SEMICOLON mode.m
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_m = _symbols[offset + 4];
					final Mode m = (Mode) _symbol_m.value;
					 return new VarDef(n, m);
				}
			},
			new Action() {	// [21] lst$vardef = vardef
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [22] lst$vardef = lst$vardef vardef
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [23] opt$lst$vardef = 
			Action.RETURN,	// [24] opt$lst$vardef = lst$vardef
			Action.RETURN,	// [25] vardefs = opt$lst$vardef
			new Action() {	// [26] local1 = LBRACE locals2.ss RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ss = _symbols[offset + 2];
					final ArrayList _list_ss = (ArrayList) _symbol_ss.value;
					final Statement[] ss = _list_ss == null ? new Statement[0] : (Statement[]) _list_ss.toArray(new Statement[_list_ss.size()]);
					 return new Block(ss);
				}
			},
			new Action() {	// [27] local1 = ID.n ASG expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new Assignment(n, b);
				}
			},
			new Action() {	// [28] local1 = FENCE SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return Fence.self();
				}
			},
			new Action() {	// [29] local1 = IF LPAREN expr.a RPAREN local.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Statement b = (Statement) _symbol_b.value;
					 return new If(a, b);
				}
			},
			new Action() {	// [30] local1 = IF LPAREN expr.a RPAREN local.b ELSE local.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Statement b = (Statement) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 7];
					final Statement c = (Statement) _symbol_c.value;
					 return new If(a, b, c);
				}
			},
			new Action() {	// [31] local1 = WHILE LPAREN expr.a RPAREN INVARIANT COLON exprs.i GAMMA COLON exprs.g local.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_i = _symbols[offset + 7];
					final ArrayList _list_i = (ArrayList) _symbol_i.value;
					final Expression[] i = _list_i == null ? new Expression[0] : (Expression[]) _list_i.toArray(new Expression[_list_i.size()]);
					final Symbol _symbol_g = _symbols[offset + 10];
					final ArrayList _list_g = (ArrayList) _symbol_g.value;
					final Expression[] g = _list_g == null ? new Expression[0] : (Expression[]) _list_g.toArray(new Expression[_list_g.size()]);
					final Symbol _symbol_b = _symbols[offset + 11];
					final Statement b = (Statement) _symbol_b.value;
					 return new While(a, i, g, b);
				}
			},
			new Action() {	// [32] local1 = error SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return Malformed.self();
				}
			},
			Action.RETURN,	// [33] expr = PREFIX
			Action.RETURN,	// [34] expr = POSTFIX
			new Action() {	// [35] expr = ID.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					 return new Id(n);
				}
			},
			new Action() {	// [36] expr = REG_ID.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					 return new Id(n);
				}
			},
			new Action() {	// [37] expr = NUM.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final Integer n = (Integer) _symbol_n.value;
					 return new Lit(n);
				}
			},
			new Action() {	// [38] expr = PLUS expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expression a = (Expression) _symbol_a.value;
					 return new PreOp("+", a);
				}
			},
			new Action() {	// [39] expr = MINUS expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expression a = (Expression) _symbol_a.value;
					 return new PreOp("-", a);
				}
			},
			new Action() {	// [40] expr = BANG expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expression a = (Expression) _symbol_a.value;
					 return new PreOp("!", a);
				}
			},
			new Action() {	// [41] expr = TILDE expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expression a = (Expression) _symbol_a.value;
					 return new PreOp("~", a);
				}
			},
			new Action() {	// [42] expr = expr.a STAR expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("*", a, b);
				}
			},
			new Action() {	// [43] expr = expr.a DIV expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("/", a, b);
				}
			},
			new Action() {	// [44] expr = expr.a MOD expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("%", a, b);
				}
			},
			new Action() {	// [45] expr = expr.a PLUS expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("+", a, b);
				}
			},
			new Action() {	// [46] expr = expr.a MINUS expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("-", a, b);
				}
			},
			new Action() {	// [47] expr = expr.a SHL expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("<<",a, b);
				}
			},
			new Action() {	// [48] expr = expr.a SHR expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp(">>",a, b);
				}
			},
			new Action() {	// [49] expr = expr.a ASHR expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp(">>>",a, b);
				}
			},
			new Action() {	// [50] expr = expr.a LT expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("<", a, b);
				}
			},
			new Action() {	// [51] expr = expr.a LE expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("<=",a, b);
				}
			},
			new Action() {	// [52] expr = expr.a GE expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp(">=",a, b);
				}
			},
			new Action() {	// [53] expr = expr.a GT expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp(">", a, b);
				}
			},
			new Action() {	// [54] expr = expr.a EQ expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("==",a, b);
				}
			},
			new Action() {	// [55] expr = expr.a NEQ expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("!=",a, b);
				}
			},
			new Action() {	// [56] expr = expr.a AMP expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("&", a, b);
				}
			},
			new Action() {	// [57] expr = expr.a CARET expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("^", a, b);
				}
			},
			new Action() {	// [58] expr = expr.a PIPE expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("|", a, b);
				}
			},
			new Action() {	// [59] expr = expr.a AND expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("&&",a, b);
				}
			},
			new Action() {	// [60] expr = expr.a OR expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expression a = (Expression) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expression b = (Expression) _symbol_b.value;
					 return new BinOp("||",a, b);
				}
			},
			new Action() {	// [61] expr = LPAREN expr.e RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expression e = (Expression) _symbol_e.value;
					 return (Symbol) e;
				}
			},
			new Action() {	// [62] expr = LOW
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Const("Low");
				}
			},
			new Action() {	// [63] expr = HIGH
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Const("High");
				}
			},
			new Action() {	// [64] expr = TRUE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Const("True");
				}
			},
			new Action() {	// [65] expr = FALSE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Const("False");
				}
			},
			new Action() {	// [66] lpred = LPRED COLON expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expression a = (Expression) _symbol_a.value;
					 return (Symbol) a;
				}
			},
			new Action() {	// [67] mode = MODE COLON NORW
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Mode("NoRW");
				}
			},
			new Action() {	// [68] mode = MODE COLON NOW
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Mode("NoW");
				}
			},
			new Action() {	// [69] mode = MODE COLON RW
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new Mode("RW");
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
